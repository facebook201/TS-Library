
## AVL树 红黑树 B树 B+树 Trie树
> AVL 是平衡二叉搜索树的鼻祖，平衡度最好，高度差保持在【-1，0，1】。查询的时间保证了 O(logn)，但每个节点要额外保存一个平衡值，或者说是高度差。


### 红黑树
**
红黑树一样也是平衡二叉搜索树，也是工业界最主要使用的二叉搜索平衡树。但平衡度红黑树没AVL那么好。也就是说，如果从高度差来说，红黑树是大于AVL的，其实也就代表着它的实际查询时间(最坏情况)略逊于AVL的。数学证明红黑树的最大深度是  , 其实最差情况它从根到叶子的最长路可以是最短路的两倍，但也不是很差，所以它的查询时间复杂度也是O（log n）。从实现角度来说，保存红黑状态，每个节点只需要一位二进制，也就是一个bit（有些做法，可以把这个bit塞到其他地方，就可以不占用额外空间了）。可AVL每个节点需要额外存储一个平衡值（数），工业界把红黑树作为一种更通用的平衡搜索数来用，Java用它来实现TreeMap, C++的std::set/map/multimap等等。**

* 它是一颗BST树

* 根节点是黑节点

* 所有的叶子节点是null 是一个黑节点（一半以上是黑节点）

* 红节点的子节点必须是黑节点

* 新插入的节点是红节点（后面可能有平衡过程变成黑节点）

* 任意一个节点 从该节点到其叶子节点的所有路径 黑节点的数目是一定相同的

* 最坏情况下左右节点数差一倍


| 父节点 | 叔节点 | 类型 | 操作                   |
| ------ | ------ | ---- | ---------------------- |
| 黑     | ——     | ——   | 无需操作               |
| 红     | 红     | ——   | 父叔都变黑、祖父变成红 |
| 红     | 黑     | 左左 | 右旋+变色              |
| 红     | 黑     | 右右 | 左旋 + 变色            |
| 红     | 黑     | 左右 | 先左旋、再右旋 变色    |
| 红     | 黑     | 右左 | 先右旋、再左旋 + 变色  |






### B/B+树
**他们是N叉平衡树，每个节点可以有更多的孩子，新的值可以插在已有的节点里，而不需要改变树的高度，
从而大量减少重新平衡和数据迁移的次数，非常适合做数据库索引这种需要持久化在磁盘，
同时需要大量查询和插入操作的应用。**



### m-阶 B树

1.根结点至少有两个子女。

2.每个中间节点都包含k-1个元素和k个孩子，其中 m/2 <= k <= m

3.每一个叶子节点都包含k-1个元素，其中 m/2 <= k <= m

4.所有的叶子结点都位于同一层。

5.每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。



### m 阶 B+树

1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。

2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。

3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。












